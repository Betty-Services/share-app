[{"name":"BarCodeScanner","type":"CONTENT_COMPONENT","allowedTypes":["CONTENT_COMPONENT"],"orientation":"HORIZONTAL","jsx":"(() => {\n  const {\n    env\n  } = B;\n  const BarcodeScannerComponent = window.BarcodeScannerComponent;\n  const isDev = env === 'dev';\n  const {\n    imagePreviewWidth,\n    imagePreviewHeight,\n    facingMode,\n    torch,\n    stopStream,\n    delay\n  } = options;\n  const [data, setData] = useState('No result');\n  const [stopStreamState, setStopStream] = useState(stopStream);\n  const [scannerLighting, setScannerLighting] = useState(torch);\n  const [facingModeState, setFacingModeState] = useState(facingMode);\n  B.defineFunction('toggleLighting', () => setScannerLighting(s => !s));\n  B.defineFunction('toggleStopStream', () => setStopStream(s => !s));\n  B.defineFunction('toggleCamera', () => setFacingModeState(facingModeState === \"environment\" ? \"user\" : \"environment\"));\n  console.log(facingModeState);\n  if (isDev) return <div><img src=\"https://assets.bettyblocks.com/25b3c337837b4838b382c50c0e5f3fc2_assets/files/barcode.gif\" /></div>;\n  return <div>\r\n        <BarcodeScannerComponent width={imagePreviewWidth} height={imagePreviewHeight} facingMode={facingModeState} torch={scannerLighting} delay={delay} onUpdate={(err, result) => {\n      if (result) {\n        setData(result.text);\n        B.triggerEvent('OnCodeScanned', result.text);\n      } else setData(\"Not Found\");\n    }} stopStream={stopStreamState} />\r\n      </div>;\n})()","styles":"B => t => {\n  const {\n    color: colorFunc,\n    Styling\n  } = B;\n  const style = new Styling(t);\n  return {\n    root: {\n      display: 'block'\n    }\n  };\n}","functions":["toggleLighting","toggleStopStream","toggleCamera"],"triggers":["OnCodeScanned"],"interactions":{},"componentHash":"0215d1258ea18fd6daa05343b327fcae7a2bf0154061f455525589521058b2e2"},{"name":"TextField","type":"CONTENT_COMPONENT","allowedTypes":[],"orientation":"HORIZONTAL","jsx":"(() => {\n  const {\n    autoComplete,\n    disabled,\n    spellCheck,\n    error,\n    multiline,\n    rows,\n    placeholder = [''],\n    variant,\n    type,\n    size,\n    fullWidth,\n    margin,\n    helperText = [''],\n    adornment,\n    adornmentIcon,\n    adornmentPosition,\n    pattern,\n    minlength,\n    maxlength,\n    minvalue,\n    maxvalue,\n    validationTypeMismatch = [''],\n    validationPatternMismatch = [''],\n    validationValueMissing = [''],\n    validationTooLong = [''],\n    validationTooShort = [''],\n    validationBelowMinimum = [''],\n    validationAboveMaximum = [''],\n    hideLabel,\n    customModelAttribute: customModelAttributeObj,\n    nameAttribute,\n    dataComponentAttribute = ['TextField']\n  } = options;\n  const {\n    FormControl,\n    Input,\n    OutlinedInput,\n    FilledInput,\n    InputLabel,\n    FormHelperText,\n    InputAdornment,\n    IconButton\n  } = window.MaterialUI.Core;\n  const {\n    env,\n    getCustomModelAttribute,\n    useText,\n    Icon\n  } = B;\n  const isDev = env === 'dev';\n  const isNumberType = type === 'number';\n  const isPasswordType = type === 'password';\n  const [isDisabled, setIsDisabled] = useState(disabled);\n  const [showPassword, togglePassword] = useState(false);\n  const [errorState, setErrorState] = useState(error);\n  const [afterFirstInvalidation, setAfterFirstInvalidation] = useState(false);\n  const [helper, setHelper] = useState(useText(helperText));\n  const {\n    id: customModelAttributeId,\n    label = [],\n    value: defaultValue = [],\n    required: defaultRequired = false\n  } = customModelAttributeObj;\n  const [currentValue, setCurrentValue] = useState(useText(defaultValue, {\n    rawValue: true\n  }));\n  const labelText = useText(label);\n  const customModelAttribute = getCustomModelAttribute(customModelAttributeId);\n  const {\n    name: customModelAttributeName,\n    validations: {\n      required: attributeRequired\n    } = {}\n  } = customModelAttribute || {};\n  const required = customModelAttribute ? attributeRequired : defaultRequired;\n  const nameAttributeValue = useText(nameAttribute);\n  const validPattern = pattern || null;\n  const validMinlength = minlength || null;\n  const validMaxlength = maxlength || null;\n  const validMinvalue = minvalue || null;\n  const validMaxvalue = maxvalue || null;\n  const patternMismatchMessage = useText(validationPatternMismatch);\n  const typeMismatchMessage = useText(validationTypeMismatch);\n  const valueMissingMessage = useText(validationValueMissing);\n  const tooLongMessage = useText(validationTooLong);\n  const tooShortMessage = useText(validationTooShort);\n  const belowMinimumMessage = useText(validationBelowMinimum);\n  const aboveMaximumMessage = useText(validationAboveMaximum);\n  const placeholderText = useText(placeholder);\n  const helperTextResolved = useText(helperText);\n  const defaultValueRawText = useText(defaultValue, {\n    rawValue: true\n  });\n  const defaultValueText = useText(defaultValue);\n  const dataComponentAttributeValue = useText(dataComponentAttribute);\n\n  const validationMessage = validityObject => {\n    if (validityObject.customError && patternMismatchMessage) {\n      return patternMismatchMessage;\n    }\n\n    if (validityObject.valid) {\n      return '';\n    }\n\n    if (validityObject.typeMismatch && typeMismatchMessage) {\n      return typeMismatchMessage;\n    }\n\n    if (validityObject.patternMismatch && patternMismatchMessage) {\n      return patternMismatchMessage;\n    }\n\n    if (validityObject.valueMissing && valueMissingMessage) {\n      return valueMissingMessage;\n    }\n\n    if (validityObject.tooLong && tooLongMessage) {\n      return tooLongMessage;\n    }\n\n    if (validityObject.tooShort && tooShortMessage) {\n      return tooShortMessage;\n    }\n\n    if (validityObject.rangeUnderflow && belowMinimumMessage) {\n      return belowMinimumMessage;\n    }\n\n    if (validityObject.rangeOverflow && aboveMaximumMessage) {\n      return aboveMaximumMessage;\n    }\n\n    return '';\n  };\n\n  const handleValidation = validation => {\n    setErrorState(!validation.valid);\n    const message = validationMessage(validation) || helperTextResolved;\n    setHelper(message);\n  };\n\n  const onKeyDown = event => {\n    if (isNumberType && (event.key === '.' || event.key === ',')) {\n      event.preventDefault();\n    }\n  };\n\n  const customPatternValidation = target => {\n    const {\n      value: eventValue,\n      validity\n    } = target;\n\n    if (!pattern) {\n      return validity;\n    }\n\n    const patternRegex = RegExp(`^${pattern}$`);\n    const isValid = patternRegex.test(eventValue);\n    target.setCustomValidity(isValid ? '' : 'Invalid field.');\n    return { ...validity,\n      valid: isValid,\n      patternMismatch: !isValid\n    };\n  };\n\n  const changeHandler = event => {\n    const {\n      target\n    } = event;\n    let {\n      validity: validation\n    } = target;\n    const {\n      value: eventValue\n    } = target;\n\n    if (isNumberType || multiline) {\n      validation = customPatternValidation(target);\n    }\n\n    const numberValue = isNumberType && eventValue && parseInt(eventValue, 10);\n\n    if (afterFirstInvalidation) {\n      handleValidation(validation);\n    }\n\n    const value = isNumberType ? numberValue : eventValue;\n    setCurrentValue(value);\n    B.triggerEvent('onChange', value);\n  };\n\n  const blurHandler = event => {\n    const {\n      target\n    } = event;\n    let {\n      validity: validation\n    } = target;\n\n    if (isNumberType || multiline) {\n      validation = customPatternValidation(target);\n    }\n\n    setAfterFirstInvalidation(!validation.valid);\n    handleValidation(validation);\n  };\n\n  const invalidHandler = event => {\n    event.preventDefault();\n    const {\n      target: {\n        validity,\n        validity: {\n          valid: isValid\n        }\n      }\n    } = event;\n    setAfterFirstInvalidation(!isValid);\n    handleValidation(validity);\n  };\n\n  B.defineFunction('Clear', () => setCurrentValue(''));\n  B.defineFunction('Enable', () => setIsDisabled(false));\n  B.defineFunction('Disable', () => setIsDisabled(true));\n  B.defineFunction('Reset', () => setCurrentValue(defaultValueRawText));\n  B.defineFunction('setValue', data => {\n    setCurrentValue(data);\n    B.triggerEvent('onChange', data);\n  });\n\n  const handleClickShowPassword = () => {\n    togglePassword(!showPassword);\n  };\n\n  const handleMouseDownPassword = event => {\n    event.preventDefault();\n  };\n\n  let InputCmp = Input;\n\n  if (variant === 'outlined') {\n    InputCmp = OutlinedInput;\n  } else if (variant === 'filled') {\n    InputCmp = FilledInput;\n  }\n\n  const passwordIcon = showPassword ? 'Visibility' : 'VisibilityOff';\n  const inputIcon = isPasswordType ? passwordIcon : adornmentIcon;\n  const hasIcon = inputIcon && inputIcon !== 'none';\n  const hasAdornment = isPasswordType ? adornment && hasIcon : adornment || hasIcon;\n  const IconCmp = hasIcon && <Icon name={inputIcon} fontSize={size} />;\n  const iconButtonOptions = {\n    edge: adornmentPosition,\n    tabIndex: isDev ? -1 : undefined\n  };\n\n  if (isPasswordType) {\n    iconButtonOptions.ariaLabel = 'toggle password visibility';\n    iconButtonOptions.onClick = handleClickShowPassword;\n    iconButtonOptions.onMouseDown = handleMouseDownPassword;\n  }\n\n  useEffect(() => {\n    if (isDev) {\n      setCurrentValue(defaultValueText);\n      setHelper(helperTextResolved);\n    }\n  }, [isDev, defaultValueText, helperTextResolved]);\n\n  const camelToSnakeCase = str => str[0].toLowerCase() + str.slice(1, str.length).replace(/[A-Z]/g, letter => `_${letter.toLowerCase()}`);\n\n  let examDataComponentAttribute = `exam_${dataComponentAttributeValue.toLowerCase()}`;\n  const {\n    getModel,\n    getProperty\n  } = B;\n\n  if (!isDev && customModelAttributeObj) {\n    if (customModelAttributeObj.id) {\n      const customAttributeObj = getCustomModelAttribute(customModelAttributeObj.id);\n\n      if (customAttributeObj && customAttributeObj.propertyId) {\n        const customPropertyObj = getProperty(customAttributeObj.propertyId);\n\n        if (customPropertyObj.modelId) {\n          const customPropertyModelObj = getModel(customPropertyObj.modelId);\n          const propertyName = `${camelToSnakeCase(customPropertyModelObj.name)}_${customPropertyObj.name}`;\n          examDataComponentAttribute = `${propertyName.toLowerCase()}_input`;\n        }\n      }\n    }\n  }\n\n  const TextFieldCmp = <FormControl classes={{\n    root: classes.formControl\n  }} variant={variant} size={size} fullWidth={fullWidth} required={required} disabled={isDisabled} margin={margin} error={errorState}>\n        {labelText && !hideLabel && <InputLabel classes={{\n      root: classes.label\n    }}>{labelText}</InputLabel>}\n        <InputCmp name={nameAttributeValue || customModelAttributeName} value={currentValue} type={isDev && type === 'number' || showPassword ? 'text' : type} multiline={multiline} autoComplete={autoComplete ? 'on' : 'off'} rows={rows} label={labelText} placeholder={placeholderText} onKeyDown={onKeyDown} onChange={changeHandler} onBlur={blurHandler} onInvalid={invalidHandler} startAdornment={hasAdornment && adornmentPosition === 'start' && <InputAdornment position={adornmentPosition}>\n                {hasIcon ? <IconButton {...iconButtonOptions}>{IconCmp}</IconButton> : adornment}\n              </InputAdornment>} endAdornment={hasAdornment && adornmentPosition === 'end' && <InputAdornment position={adornmentPosition}>\n                {hasIcon ? <IconButton {...iconButtonOptions}>{IconCmp}</IconButton> : adornment}\n              </InputAdornment>} inputProps={{\n      pattern: validPattern,\n      minLength: validMinlength,\n      maxLength: validMaxlength,\n      min: validMinvalue,\n      max: validMaxvalue,\n      tabIndex: isDev ? -1 : undefined,\n      spellCheck\n    }} data-component={dataComponentAttributeValue} data-exam-component={examDataComponentAttribute} />\n        {helper && <FormHelperText classes={{\n      root: classes.helper\n    }}>\n            {helper}\n          </FormHelperText>}\n      </FormControl>;\n  return isDev ? <div className={classes.root}>{TextFieldCmp}</div> : TextFieldCmp;\n})()","styles":"B => t => {\n  const {\n    Styling\n  } = B;\n  const style = new Styling(t);\n  return {\n    root: {\n      display: ({\n        options: {\n          fullWidth\n        }\n      }) => fullWidth ? 'block' : 'inline-block',\n      '& > *': {\n        pointerEvents: 'none'\n      }\n    },\n    label: {\n      color: ({\n        options: {\n          labelColor\n        }\n      }) => [style.getColor(labelColor), '!important'],\n      '&.Mui-focused': {\n        color: ({\n          options: {\n            borderFocusColor\n          }\n        }) => [style.getColor(borderFocusColor), '!important']\n      },\n      '&.Mui-error, &.Mui-error .Mui-error': {\n        color: ({\n          options: {\n            errorColor\n          }\n        }) => [style.getColor(errorColor), '!important']\n      },\n      '&.Mui-disabled': {\n        pointerEvents: 'none',\n        opacity: '0.7'\n      }\n    },\n    helper: {\n      color: ({\n        options: {\n          helperColor\n        }\n      }) => [style.getColor(helperColor), '!important'],\n      '&.Mui-error': {\n        color: ({\n          options: {\n            errorColor\n          }\n        }) => [style.getColor(errorColor), '!important']\n      }\n    },\n    formControl: {\n      '& .MuiInputBase-root': {\n        color: ({\n          options: {\n            textColor\n          }\n        }) => [style.getColor(textColor), '!important'],\n        backgroundColor: ({\n          options: {\n            backgroundColor,\n            variant\n          }\n        }) => variant !== 'standard' && [style.getColor(backgroundColor), '!important'],\n        '&:hover': {\n          '& .MuiOutlinedInput-notchedOutline, & .MuiFilledInput-underline, & .MuiInput-underline': {\n            borderColor: ({\n              options: {\n                borderHoverColor\n              }\n            }) => [style.getColor(borderHoverColor), '!important']\n          }\n        },\n        '&.Mui-focused, &.Mui-focused:hover': {\n          '& .MuiOutlinedInput-notchedOutline, & .MuiFilledInput-underline, & .MuiInput-underline': {\n            borderColor: ({\n              options: {\n                borderFocusColor\n              }\n            }) => [style.getColor(borderFocusColor), '!important']\n          }\n        },\n        '& fieldset': {\n          top: ({\n            options: {\n              hideLabel\n            }\n          }) => hideLabel ? 0 : null\n        },\n        '& legend': {\n          display: ({\n            options: {\n              hideLabel\n            }\n          }) => hideLabel ? ['none', '!important'] : null,\n          overflow: 'hidden'\n        },\n        '& input': {\n          '&::placeholder': {\n            color: ({\n              options: {\n                placeholderColor\n              }\n            }) => [style.getColor(placeholderColor), '!important']\n          }\n        },\n        '&.Mui-disabled': {\n          pointerEvents: 'none',\n          opacity: '0.7'\n        }\n      },\n      '& .MuiIconButton-root': {\n        color: ({\n          options: {\n            textColor\n          }\n        }) => [style.getColor(textColor), '!important']\n      },\n      '& .MuiOutlinedInput-notchedOutline, & .MuiFilledInput-underline, & .MuiInput-underline': {\n        borderColor: ({\n          options: {\n            borderColor\n          }\n        }) => [style.getColor(borderColor), '!important']\n      },\n      '& .MuiInput-underline, & .MuiFilledInput-underline': {\n        '&::before, &::after': {\n          borderColor: ({\n            options: {\n              borderColor\n            }\n          }) => [style.getColor(borderColor), '!important']\n        },\n        '&:hover': {\n          '&::before, &::after': {\n            borderColor: ({\n              options: {\n                borderHoverColor\n              }\n            }) => [style.getColor(borderHoverColor), '!important']\n          }\n        },\n        '&.Mui-focused::before, &.Mui-focused::after, &.Mui-focused:hover::before, &.Mui-focused:hover::after': {\n          borderColor: ({\n            options: {\n              borderFocusColor\n            }\n          }) => [style.getColor(borderFocusColor), '!important']\n        }\n      },\n      '& .MuiInputBase-root.Mui-error, & .MuiInputBase-root.Mui-error:hover, & .MuiInputBase-root.Mui-error.Mui-focused, & .MuiInputBase-root.Mui-error.Mui-focused:hover': {\n        '& .MuiOutlinedInput-notchedOutline, & .MuiFilledInput-underline, & .MuiInput-underline': {\n          borderColor: ({\n            options: {\n              errorColor\n            }\n          }) => [style.getColor(errorColor), '!important']\n        },\n        '&.MuiInput-underline, &.MuiFilledInput-underline': {\n          '&::before, &::after': {\n            borderColor: ({\n              options: {\n                errorColor\n              }\n            }) => [style.getColor(errorColor), '!important']\n          },\n          '&:hover': {\n            '&::before, &::after': {\n              borderColor: ({\n                options: {\n                  errorColor\n                }\n              }) => [style.getColor(errorColor), '!important']\n            }\n          },\n          '&.Mui-focused::before, &.Mui-focused::after, &.Mui-focused:hover::before, &.Mui-focused:hover::after': {\n            borderColor: ({\n              options: {\n                errorColor\n              }\n            }) => [style.getColor(errorColor), '!important']\n          }\n        }\n      }\n    }\n  };\n}","functions":["Clear","Enable","Disable","Reset","setValue"],"triggers":["onChange","onChange"],"interactions":{},"componentHash":"2c64767ea06297734200a8c63b5348cab4f693d9afa2b019cc81de2a990b69ac"}]
