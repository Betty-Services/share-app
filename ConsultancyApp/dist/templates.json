[{"name":"Chart","type":"CONTAINER_COMPONENT","allowedTypes":[],"orientation":"HORIZONTAL","jsx":"(() => {\n  const {\n    env,\n    useAllQuery,\n    useFilter,\n    useText,\n    getProperty\n  } = B;\n  const isDev = env === 'dev';\n  const {\n    model,\n    filter,\n    labels,\n    title,\n    properties,\n    xAxisProperty,\n    serieColors,\n    chartType,\n    stacked,\n    dataLabel,\n    hideYAxis,\n    xAxisTitle,\n    yAxisTitle,\n    showTooltip,\n    showGrid,\n    showLegend,\n    legendPosition,\n    color,\n    backgroundColor,\n    divHeight\n  } = options;\n  const Chart = window.Charts;\n  const {\n    Skeleton\n  } = window.MaterialUI.Lab;\n  const chartTitle = useText(title);\n  const props = properties.split('\\n');\n  const colors = serieColors ? serieColors.split('\\n') : undefined;\n  const xAxisProp = !isDev && xAxisProperty ? getProperty(xAxisProperty).name : [];\n  const parsedYAxisTitle = useText(yAxisTitle);\n  const parsedXAxisTitle = useText(xAxisTitle);\n  const [newFilter, setNewFilter] = useState({});\n  B.defineFunction('updateFilter', updatedFilter => {\n    debugger;\n\n    if (updatedFilter.filter != undefined) {\n      setNewFilter(prevFilter => ({ ...prevFilter,\n        [updatedFilter.label]: updatedFilter.filter['_and'][0]\n      }));\n    } else {\n      const filterCopy = { ...newFilter\n      };\n      delete filterCopy[updatedFilter.label];\n      setNewFilter(filterCopy);\n    }\n  });\n  let defaultSeries = [{\n    data: [450, 40]\n  }];\n  let defaultLabels = ['Panda', 'Unicorn'];\n  const background = !isDev ? artifact.theme.colors[backgroundColor.toLowerCase()] : 'white';\n  const barColor = !isDev ? artifact.theme.colors[color.toLowerCase()] : 'blue';\n  const defaultOptions = {\n    options: {\n      chart: {\n        type: chartType,\n        stacked: stacked,\n        toolbar: {\n          show: true,\n          tools: {\n            download: false\n          }\n        },\n        background: background\n      },\n      dataLabels: {\n        enabled: dataLabel,\n        position: 'center'\n      },\n      legend: {\n        show: showLegend,\n        position: legendPosition\n      },\n      labels: defaultLabels,\n      grid: {\n        show: showGrid\n      },\n      yaxis: {\n        show: !hideYAxis,\n        min: 0,\n        title: {\n          text: parsedYAxisTitle\n        }\n      },\n      xaxis: {\n        title: {\n          text: parsedXAxisTitle\n        }\n      },\n      title: {\n        text: chartTitle,\n        align: 'center'\n      }\n    },\n    series: defaultSeries\n  };\n  const devChart = isDev && <div className={[classes.root, isDev ? classes.pristine : ''].join(' ')}>\n\t\t\t\t<Chart options={defaultOptions.options} series={defaultOptions.series} type={chartType} height={divHeight} />\n\t\t\t</div>; // const getDataUri = () => {\n  // \tApexCharts.exec(chartIdentifier, 'dataURI').then(({ imgURI }) => {\n  // \t\tB.triggerEvent('sendChartImage', { name: inputName, value: imgURI });\n  // \t});\n  // };\n\n  const chartOptions = !isDev && {\n    options: {\n      chart: {\n        type: chartType,\n        stacked: stacked,\n        toolbar: {\n          show: true,\n          tools: {\n            download: false\n          }\n        },\n        background: background\n      },\n      labels: labels.split('\\n'),\n      grid: {\n        show: showGrid\n      },\n      dataLabels: {\n        enabled: dataLabel,\n        position: 'center'\n      },\n      legend: {\n        show: showLegend,\n        position: legendPosition\n      },\n      colors: colors,\n      yaxis: {\n        show: !hideYAxis,\n        tickAmount: 1,\n        forceNiceScale: true,\n        decimalsInFloat: 0,\n        title: {\n          text: '',\n          rotate: -90\n        },\n        labels: {\n          formatter: function (val) {\n            return val.toFixed(0);\n          }\n        }\n      },\n      xaxis: {\n        labels: {\n          hideOverlappingLabels: false,\n          rotate: 0\n        },\n        title: {}\n      },\n      tooltip: {\n        enabled: showTooltip,\n        y: {\n          formatter: function (value, opts) {\n            const description = opts.w.config.series[opts.seriesIndex].data[opts.dataPointIndex].description;\n            return description;\n          }\n        }\n      },\n      title: {\n        text: chartTitle,\n        align: 'center'\n      }\n    },\n    series: []\n  };\n  const where = { ...useFilter(filter),\n    ...(Object.values(newFilter).length > 0 ? {\n      _and: Object.values(newFilter)\n    } : {})\n  };\n\n  const FetchChart = () => {\n    const {\n      loading,\n      error,\n      data,\n      refetch\n    } = model && useAllQuery(model, {\n      rawFilter: where,\n      skip: 0,\n      take: 6\n    });\n    B.defineFunction('Refetch', () => {\n      refetch();\n    });\n\n    if (loading) {\n      B.triggerEvent('onLoad', loading);\n      return <div>\n\t\t\t\t\t\t<Skeleton width='100%' height={150} variant='rect' animation='wave' />\n\t\t\t\t\t</div>;\n    }\n\n    if (error) {\n      B.triggerEvent('onError', error.message);\n      return null;\n    }\n\n    if (data && data.id) {\n      B.triggerEvent('onSuccess', data);\n    } else {\n      B.triggerEvent('onNoResults');\n    }\n\n    let series = [];\n    let categories = [];\n\n    if (data != undefined && data.results.length > 0) {\n      const chartData = data.results.reverse();\n      const parsedYAxisTitle = !hideYAxis && yAxisTitle !== undefined ? useText(yAxisTitle) : null;\n      const parsedXAxisTitle = xAxisTitle !== undefined ? useText(xAxisTitle) : null;\n      const labelsArray = labels.split('\\n');\n      labelsArray.forEach(serieLabel => series.push({\n        name: serieLabel,\n        data: []\n      }));\n      chartData.forEach(serie => {\n        categories.push(serie[xAxisProp]);\n        props !== undefined ? props.forEach((prop, propIndex) => {\n          series[propIndex].data.push({\n            x: propIndex == 0 ? 'Low' : propIndex === 1 ? 'Medium' : 'High',\n            y: serie[prop],\n            description: serie[propIndex == 0 ? 'companiesLow' : propIndex === 1 ? 'companiesMedium' : 'companiesHigh']\n          });\n        }) : serieProps.forEach((serieProp, propIndex) => series[propIndex].data.push(serie[serieProp]));\n      });\n      chartOptions.options.xaxis.categories = categories;\n      chartOptions.options.yaxis.title.text = parsedYAxisTitle ? parsedYAxisTitle : '';\n      chartOptions.options.xaxis.title.text = parsedXAxisTitle ? parsedXAxisTitle : '';\n    }\n\n    return data && <div className={classes.root}>\n\t\t\t\t\t\t<Chart options={chartOptions.options} series={series} type={chartType} height={divHeight} />\n\t\t\t\t\t</div>;\n  };\n\n  return isDev ? <div>{devChart}</div> : FetchChart();\n})()","styles":"B => t => {\n  const style = new B.Styling(t);\n  return {\n    root: {\n      height: '100%',\n      width: '100%'\n    },\n    hidden: {\n      visibility: 'hidden',\n      zIndex: '-999',\n      position: 'absolute',\n      width: '800px',\n      height: '300px'\n    },\n    empty: {\n      display: 'flex',\n      alignItems: 'center',\n      justifyContent: 'center',\n      minHeight: '4rem',\n      height: '100%',\n      width: '100%',\n      fontSize: '0.75rem',\n      color: '#262A3A',\n      textTransform: 'uppercase',\n      boxSizing: 'border-box'\n    },\n    pristine: {\n      borderWidth: '0.0625rem',\n      borderColor: '#AFB5C8',\n      borderStyle: 'dashed',\n      backgroundColor: '#F0F1F5'\n    },\n    dataSets: {\n      color: '#eb4034',\n      display: 'flex',\n      flexDirection: 'row',\n      justifyContent: 'center'\n    }\n  };\n}","functions":["updateFilter","Refetch"],"triggers":["onLoad","onError","onSuccess","onNoResults"],"interactions":{},"componentHash":"9f6e1a52db70273d8079cc3ee440b6c94cab17f48764c750cae003a1546a2b09"},{"name":"SelfbuilderLevelChart","type":"CONTAINER_COMPONENT","allowedTypes":[],"orientation":"HORIZONTAL","jsx":"(() => {\n  const {\n    env,\n    Query,\n    useAllQuery,\n    useFilter,\n    useText,\n    getProperty,\n    getModel\n  } = B;\n  const {\n    gql\n  } = window;\n  const isDev = env === 'dev';\n  const {\n    model,\n    filter,\n    labels,\n    title,\n    properties,\n    xAxisProperty,\n    serieLabels,\n    serieProperties,\n    serieColors,\n    chartType,\n    stacked,\n    dataLabel,\n    hideYAxis,\n    yAxisTitle,\n    xAxisTitle,\n    showTooltip,\n    showGrid,\n    showLegend,\n    legendPosition,\n    color,\n    backgroundColor,\n    divHeight\n  } = options;\n  const Chart = window.Charts; // const ApexCharts = window.ApexCharts;\n\n  const {\n    Skeleton\n  } = window.MaterialUI.Lab;\n  const [newFilter, setNewFilter] = useState({});\n  const chartTitle = useText(title);\n  const props = properties !== '' ? properties.split('\\n') : undefined;\n  const serieProps = serieProperties.split('\\n');\n  const labelsProp = labels;\n  const colors = serieColors ? serieColors.split('\\n') : undefined;\n  const xAxisProp = !isDev && xAxisProperty ? getProperty(xAxisProperty).name : [];\n  const parsedYAxisTitle = useText(yAxisTitle);\n  const parsedXAxisTitle = useText(xAxisTitle);\n  let defaultSeries = [{\n    data: [450, 40]\n  }];\n  let defaultLabels = ['Panda', 'Unicorn'];\n  const background = !isDev ? artifact.theme.colors[backgroundColor.toLowerCase()] : 'white';\n  const barColor = !isDev ? artifact.theme.colors[color.toLowerCase()] : 'blue';\n  B.defineFunction('updateFilter', updatedFilter => {\n    if (updatedFilter.filter != undefined) {\n      setNewFilter(updatedFilter.filter);\n    } else {\n      setNewFilter({});\n    }\n  });\n  const defaultOptions = {\n    options: {\n      chart: {\n        type: chartType,\n        stacked: stacked,\n        toolbar: {\n          show: false,\n          tools: {\n            download: false\n          }\n        },\n        background: background\n      },\n      dataLabels: {\n        enabled: dataLabel,\n        position: 'center'\n      },\n      legend: {\n        show: showLegend,\n        position: legendPosition\n      },\n      labels: defaultLabels,\n      grid: {\n        show: showGrid\n      },\n      xaxis: {\n        title: {\n          text: parsedXAxisTitle\n        }\n      },\n      yaxis: {\n        show: !hideYAxis,\n        min: 0,\n        title: {\n          show: parsedYAxisTitle != undefined,\n          text: parsedYAxisTitle\n        }\n      },\n      title: {\n        text: chartTitle,\n        align: 'center'\n      }\n    },\n    series: defaultSeries\n  };\n  const devChart = isDev && <div className={[classes.root, isDev ? classes.pristine : ''].join(' ')}>\n\t\t\t\t<Chart options={defaultOptions.options} series={defaultOptions.series} type={chartType} height={divHeight} />\n\t\t\t</div>;\n  const chartOptions = !isDev && {\n    options: {\n      chart: {\n        type: chartType,\n        stacked: stacked,\n        toolbar: {\n          show: false,\n          tools: {\n            download: false\n          }\n        },\n        background: background\n      },\n      labels: labels.split('\\n'),\n      grid: {\n        show: showGrid\n      },\n      dataLabels: {\n        enabled: dataLabel,\n        position: 'center'\n      },\n      legend: {\n        show: showLegend,\n        position: legendPosition\n      },\n      colors: colors,\n      yaxis: {\n        show: !hideYAxis,\n        tickAmount: 1,\n        min: 0,\n        max: 10,\n        forceNiceScale: true,\n        decimalsInFloat: 0,\n        title: {}\n      },\n      xaxis: {\n        labels: {\n          hideOverlappingLabels: false,\n          rotate: 0\n        },\n        title: {}\n      },\n      tooltip: {\n        enabled: showTooltip\n      },\n      title: {\n        text: chartTitle,\n        align: 'center'\n      }\n    },\n    series: []\n  };\n  const where = { ...useFilter(filter),\n    ...(Object.values(newFilter).length > 0 ? newFilter : {})\n  };\n\n  const FetchChart = () => {\n    const queryKey = `all${getModel(model).name}`;\n    const q = 'query ($skip: Int, $take: Int) {\\\n        ' + queryKey + '(skip: $skip, take: $take, where: $where) {\\\n            results {\\\n              fullName\\\n              selfbuilderLevels {\\\n                level\\\n              }\\\n            }\\\n            totalCount\\\n        }\\\n      }';\n    const g = gql(q);\n    return <Query query={g} variables={{\n      where,\n      skip: 0,\n      take: 200\n    }}>\n\t\t\t\t\t{({\n        loading,\n        error,\n        data,\n        refetch\n      }) => {\n        if (data && !loading && !error) {\n          const {\n            results: chartData,\n            totalCount\n          } = data[queryKey];\n          let series = [];\n\n          if (chartData != undefined && chartData.length > 0) {\n            const parsedYAxisTitle = !hideYAxis && yAxisTitle !== undefined ? useText(yAxisTitle) : null;\n            const parsedXAxisTitle = xAxisTitle !== undefined ? useText(xAxisTitle) : null;\n            let amounts = [];\n            chartData.forEach((selfbuilder, index) => {\n              let count = 0;\n              series.push({\n                name: selfbuilder.fullName,\n                data: []\n              });\n              selfbuilder.selfbuilderLevels.forEach(selfbuilderLevel => {\n                count++;\n                series[index].data.push(selfbuilderLevel.level);\n              });\n              amounts.push(count);\n            });\n            const highestAmount = Math.max(...amounts);\n            const categories = Array.from(new Array(highestAmount), (x, i) => i + 1);\n            chartOptions.options.xaxis.categories = categories;\n            chartOptions.options.yaxis.title.text = parsedYAxisTitle ? parsedYAxisTitle : '';\n            chartOptions.options.xaxis.title.text = parsedXAxisTitle ? parsedXAxisTitle : '';\n          }\n\n          return data && <div className={classes.root}>\n\t\t\t\t\t\t\t\t\t\t<Chart options={chartOptions.options} series={series} type={chartType} height={divHeight} />\n\t\t\t\t\t\t\t\t\t</div>;\n        }\n\n        return <></>;\n      }}\n\t\t\t\t</Query>;\n  }; // const FetchChart = () => {\n  // \tconst { loading, error, data, refetch } =\n  // \t\tmodel &&\n  // \t\tuseAllQuery(model, {\n  // \t\t\trawFilter: where,\n  // \t\t\tskip: 0,\n  // \t\t\ttake: 200,\n  // \t\t});\n  // \tB.defineFunction('Refetch', () => {\n  // \t\trefetch();\n  // \t});\n  // \tif (loading) {\n  // \t\tB.triggerEvent('onLoad', loading);\n  // \t\treturn (\n  // \t\t\t<div>\n  // \t\t\t\t<Skeleton\n  // \t\t\t\t\twidth='100%'\n  // \t\t\t\t\theight={150}\n  // \t\t\t\t\tvariant='rect'\n  // \t\t\t\t\tanimation='wave'\n  // \t\t\t\t/>\n  // \t\t\t</div>\n  // \t\t);\n  // \t}\n  // \tif (error) {\n  // \t\tB.triggerEvent('onError', error.message);\n  // \t\treturn null;\n  // \t}\n  // \tif (data && data.id) {\n  // \t\tB.triggerEvent('onSuccess', data);\n  // \t} else {\n  // \t\tB.triggerEvent('onNoResults');\n  // \t}\n\n\n  return isDev ? <div>{devChart}</div> : FetchChart();\n})()","styles":"B => t => {\n  const style = new B.Styling(t);\n  return {\n    root: {\n      height: '100%',\n      width: '100%'\n    },\n    hidden: {\n      visibility: 'hidden',\n      zIndex: '-999',\n      position: 'absolute',\n      width: '800px',\n      height: '300px'\n    },\n    empty: {\n      display: 'flex',\n      alignItems: 'center',\n      justifyContent: 'center',\n      minHeight: '4rem',\n      height: '100%',\n      width: '100%',\n      fontSize: '0.75rem',\n      color: '#262A3A',\n      textTransform: 'uppercase',\n      boxSizing: 'border-box'\n    },\n    pristine: {\n      borderWidth: '0.0625rem',\n      borderColor: '#AFB5C8',\n      borderStyle: 'dashed',\n      backgroundColor: '#F0F1F5'\n    },\n    dataSets: {\n      color: '#eb4034',\n      display: 'flex',\n      flexDirection: 'row',\n      justifyContent: 'center'\n    }\n  };\n}","functions":["updateFilter"],"triggers":[],"interactions":{},"componentHash":"c4801bf07a4bfb332b9506c08181ad808e479f096e73aab3bc9753147eeb4672"}]
