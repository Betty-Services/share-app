[{"name":"DynamicStepper","type":"CONTAINER_COMPONENT","allowedTypes":["BODY_COMPONENT","CONTAINER_COMPONENT","CONTENT_COMPONENT"],"orientation":"HORIZONTAL","jsx":"(() => {\n  const {\n    Stepper,\n    Step,\n    StepLabel,\n    StepButton,\n    StepContent,\n    MobileStepper,\n    Button\n  } = window.MaterialUI.Core;\n  const {\n    Icons\n  } = window.MaterialUI;\n  const {\n    env,\n    useText,\n    getProperty,\n    useFilter,\n    useAllQuery,\n    ModelProvider,\n    InteractionScope\n  } = B;\n  const {\n    model,\n    filter,\n    order,\n    orderBy,\n    labelProperty,\n    iconProperty,\n    variant,\n    type,\n    alternativeLabel,\n    buttonNext,\n    buttonPrev\n  } = options;\n  const isDev = env === 'dev';\n  const isEmpty = children.length === 0;\n  const activeStepIndex = 0;\n  const [activeStep, setActiveStep] = useState(activeStepIndex);\n  const buttonNextText = useText(buttonNext);\n  const buttonPrevText = useText(buttonPrev);\n  const isLinear = variant === 'linear';\n  const numRendersRef = useRef(1);\n  let steps = [];\n\n  const handleButtons = step => {\n    if (step === 0) {\n      B.triggerEvent('onFirstStep');\n    } else if (step === steps.length - 1) {\n      B.triggerEvent('onLastStep');\n    } else {\n      B.triggerEvent('onBetweenStep');\n    }\n  };\n\n  const handleNext = () => {\n    setActiveStep(prevActiveStep => {\n      const nextStep = prevActiveStep + 1;\n\n      if (nextStep > steps.length - 1) {\n        return prevActiveStep;\n      }\n\n      handleButtons(nextStep);\n      return nextStep;\n    });\n  };\n\n  const handleBack = () => {\n    setActiveStep(prevActiveStep => {\n      const nextStep = prevActiveStep - 1;\n\n      if (nextStep < 0) {\n        return prevActiveStep;\n      }\n\n      handleButtons(nextStep);\n      return nextStep;\n    });\n  };\n\n  const handleStep = step => () => {\n    if (step < steps.length && step > -1) {\n      handleButtons(step);\n      setActiveStep(step);\n    }\n  };\n\n  const BuilderLayout = () => {\n    const isActive = index === activeStep;\n    const hasIcon = !(iconProperty === '' || iconProperty.id === '');\n    const icon = hasIcon ? 'Star' : 'None';\n    let stepProps = {};\n    let labelProps = {};\n\n    const IconCmp = () => hasIcon && React.createElement(Icons[icon], {\n      className: [classes.stepIcon, isActive ? classes.stepIconActive : ''].join(' ')\n    });\n\n    if (hasIcon) {\n      labelProps = { ...labelProps,\n        StepIconComponent: IconCmp\n      };\n    }\n\n    return <>\n\t\t\t\t\t<Stepper nonLinear={!isLinear} alternativeLabel={alternativeLabel} activeStep={activeStep} orientation={type} classes={{\n        root: classes.root\n      }}>\n\t\t\t\t\t\t{[...Array(2)].map((e, index) => <Step key={`Step ${index + 1}`} {...stepProps}>\n\t\t\t\t\t\t\t\t{isLinear ? <StepLabel classes={{\n            root: classes.stepLabel\n          }} {...labelProps}>\n\t\t\t\t\t\t\t\t\t\t{labelText}\n\t\t\t\t\t\t\t\t\t</StepLabel> : <StepButton classes={{\n            root: classes.stepButton\n          }} onClick={handleStep(index)}>\n\t\t\t\t\t\t\t\t\t\t<StepLabel classes={{\n              root: classes.stepLabel\n            }} {...labelProps}>\n\t\t\t\t\t\t\t\t\t\t\t{`Step ${index + 1}`}\n\t\t\t\t\t\t\t\t\t\t</StepLabel>\n\t\t\t\t\t\t\t\t\t</StepButton>}\n\t\t\t\t\t\t\t\t{type === 'vertical' && <StepContent>\n\t\t\t\t\t\t\t\t\t\t<div className={[classes.wrapper, isEmpty ? classes.empty : ''].join(' ')}>\n\t\t\t\t\t\t\t\t\t\t\t{children.length > 0 ? children : 'Step'}\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t</StepContent>}\n\t\t\t\t\t\t\t</Step>)}\n\t\t\t\t\t</Stepper>\n\t\t\t\t\t{(type === 'horizontal' || type === 'mobile') && <div className={[classes.wrapper, isEmpty ? classes.empty : ''].join(' ')}>\n\t\t\t\t\t\t\t{children.length > 0 ? children : 'Step'}\n\t\t\t\t\t\t</div>}\n\t\t\t\t</>;\n  };\n\n  const orderByPath = Array.isArray(orderBy.id) ? orderBy.id : null;\n  const sort = !isDev && orderByPath ? orderByPath.reduceRight((acc, property, index) => {\n    const prop = getProperty(property);\n    return index === orderByPath.length - 1 ? {\n      [prop.name]: order.toUpperCase()\n    } : {\n      [prop.name]: acc\n    };\n  }, {}) : {};\n  const where = useFilter(filter);\n  const {\n    loading,\n    error,\n    data,\n    refetch\n  } = model && useAllQuery(model, {\n    rawFilter: where,\n    skip: 0,\n    take: 200,\n    variables: { ...(orderByPath ? {\n        sort: {\n          relation: sort\n        }\n      } : {})\n    },\n\n    onCompleted(res) {\n      const hasResult = res && res.results && res.results.length > 0;\n\n      if (hasResult) {\n        B.triggerEvent('onSuccess', res.results);\n      } else {\n        B.triggerEvent('onNoResults');\n      }\n    },\n\n    onError(resp) {\n      B.triggerEvent('onError', resp);\n    }\n\n  });\n  B.defineFunction('Refetch', () => refetch());\n  const mounted = useRef(false);\n  useEffect(() => {\n    mounted.current = true;\n    return () => {\n      mounted.current = false;\n    };\n  }, []);\n  useEffect(() => {\n    if (mounted.current && loading) {\n      B.triggerEvent('onLoad', loading);\n    }\n  }, [loading]);\n\n  const StepperCmp = () => {\n    if (loading) return <div className={classes.skeleton} />;\n\n    if (error && displayError) {\n      return <span>{error.message}</span>;\n    }\n\n    const {\n      results\n    } = data || {};\n    steps = results;\n    return <>\n\t\t\t\t\t<Stepper nonLinear={!isLinear} alternativeLabel={alternativeLabel} activeStep={activeStep} orientation={type} classes={{\n        root: classes.root\n      }}>\n\t\t\t\t\t\t{results.map((item, index) => {\n          const labelText = labelProperty === '' || labelProperty.id === '' ? undefined : getProperty(labelProperty).name;\n          const icon = iconProperty === '' || iconProperty.id === '' ? undefined : getProperty(iconProperty).name;\n          const isActive = index === activeStep;\n          const hasIcon = icon !== undefined;\n          let stepProps = {};\n          let labelProps = {};\n\n          const IconCmp = () => hasIcon && React.createElement(Icons[icon], {\n            className: [classes.stepIcon, isActive ? classes.stepIconActive : ''].join(' ')\n          });\n\n          if (hasIcon) {\n            labelProps = { ...labelProps,\n              StepIconComponent: IconCmp\n            };\n          }\n\n          const StepComponent = <Step key={item[labelText]} {...stepProps}>\n\t\t\t\t\t\t\t\t\t{isLinear ? <StepLabel classes={{\n              root: classes.stepLabel\n            }} {...labelProps}>\n\t\t\t\t\t\t\t\t\t\t\t{item[labelText]}\n\t\t\t\t\t\t\t\t\t\t</StepLabel> : <StepButton classes={{\n              root: classes.stepButton\n            }} onClick={handleStep(index)}>\n\t\t\t\t\t\t\t\t\t\t\t<StepLabel classes={{\n                root: classes.stepLabel\n              }} {...labelProps}>\n\t\t\t\t\t\t\t\t\t\t\t\t{item[labelText]}\n\t\t\t\t\t\t\t\t\t\t\t</StepLabel>\n\t\t\t\t\t\t\t\t\t\t</StepButton>}\n\t\t\t\t\t\t\t\t\t{type === 'vertical' && <StepContent>\n\t\t\t\t\t\t\t\t\t\t\t<ModelProvider key={item.id} value={item} id={model}>\n\t\t\t\t\t\t\t\t\t\t\t\t<InteractionScope model={model}>\n\t\t\t\t\t\t\t\t\t\t\t\t\t{context => {\n                    return <>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{children.length !== 0 && isActive ? children : <></>}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t</>;\n                  }}\n\t\t\t\t\t\t\t\t\t\t\t\t</InteractionScope>\n\t\t\t\t\t\t\t\t\t\t\t</ModelProvider>\n\t\t\t\t\t\t\t\t\t\t</StepContent>}\n\t\t\t\t\t\t\t\t</Step>;\n          return StepComponent;\n        })}\n\t\t\t\t\t</Stepper>\n\t\t\t\t\t{type === 'horizontal' && <>\n\t\t\t\t\t\t\t{results.map((item, index) => {\n          const isActive = index === activeStep;\n          return <ModelProvider key={item.id} value={item} id={model}>\n\t\t\t\t\t\t\t\t\t\t<InteractionScope model={model}>\n\t\t\t\t\t\t\t\t\t\t\t{context => {\n                return <>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{children.length !== 0 && isActive ? children : <></>}\n\t\t\t\t\t\t\t\t\t\t\t\t\t</>;\n              }}\n\t\t\t\t\t\t\t\t\t\t</InteractionScope>\n\t\t\t\t\t\t\t\t\t</ModelProvider>;\n        })}\n\t\t\t\t\t\t</>}\n\t\t\t\t</>;\n  };\n\n  const {\n    KeyboardArrowLeft,\n    KeyboardArrowRight\n  } = Icons;\n\n  const MobileStepperCmp = () => {\n    if (loading) return <div className={classes.skeleton} />;\n\n    if (error && displayError) {\n      return <span>{error.message}</span>;\n    }\n\n    const {\n      results\n    } = data || {};\n    steps = results;\n    const maxSteps = steps.length;\n    return <>\n\t\t\t\t\t{results.map((item, index) => {\n        const isActive = index === activeStep;\n        return <ModelProvider key={item.id} value={item} id={model}>\n\t\t\t\t\t\t\t\t<InteractionScope model={model}>\n\t\t\t\t\t\t\t\t\t{context => {\n              return <>\n\t\t\t\t\t\t\t\t\t\t\t\t{children.length !== 0 && isActive ? children : <></>}\n\t\t\t\t\t\t\t\t\t\t\t</>;\n            }}\n\t\t\t\t\t\t\t\t</InteractionScope>\n\t\t\t\t\t\t\t</ModelProvider>;\n      })}\n\t\t\t\t\t<MobileStepper steps={maxSteps} position='static' variant='text' activeStep={activeStep} classes={{\n        root: classes.mobileRoot\n      }} nextButton={<Button size='small' onClick={handleNext} disabled={activeStep === maxSteps - 1} classes={{\n        root: classes.stepButtonMobile\n      }}>\n\t\t\t\t\t\t\t\t{buttonNextText}\n\t\t\t\t\t\t\t\t<KeyboardArrowRight />\n\t\t\t\t\t\t\t</Button>} backButton={<Button size='small' onClick={handleBack} disabled={activeStep === 0} classes={{\n        root: classes.stepButtonMobile\n      }}>\n\t\t\t\t\t\t\t\t<KeyboardArrowLeft />\n\t\t\t\t\t\t\t\t{buttonPrevText}\n\t\t\t\t\t\t\t</Button>} />\n\t\t\t\t</>;\n  };\n\n  const StepperComponent = !isDev ? type === 'mobile' ? MobileStepperCmp() : StepperCmp() : null;\n  B.defineFunction('NextStep', () => handleNext());\n  B.defineFunction('PreviousStep', () => handleBack());\n  numRendersRef.current += 1;\n  return isDev ? <div>{BuilderLayout()}</div> : StepperComponent;\n})()","styles":"B => t => {\n  const {\n    env,\n    Styling\n  } = B;\n  const style = new Styling(t);\n  const isDev = env === 'dev';\n  return {\n    root: {\n      backgroundColor: ({\n        options: {\n          backgroundColor\n        }\n      }) => [style.getColor(backgroundColor), '!important'],\n      '& .MuiStepConnector-line': {\n        borderColor: ({\n          options: {\n            connectorColor\n          }\n        }) => style.getColor(connectorColor)\n      },\n      '& .MuiStepContent-root': {\n        borderColor: ({\n          options: {\n            connectorColor\n          }\n        }) => style.getColor(connectorColor)\n      }\n    },\n    stepLabel: {\n      '& .MuiStepIcon-root': {\n        color: ({\n          options: {\n            inactiveColor\n          }\n        }) => style.getColor(inactiveColor),\n        '&.MuiStepIcon-active': {\n          color: ({\n            options: {\n              activeColor\n            }\n          }) => style.getColor(activeColor)\n        }\n      },\n      '& .MuiStepLabel-label': {\n        color: ({\n          options: {\n            inactiveLabelColor\n          }\n        }) => style.getColor(inactiveLabelColor),\n        '&.MuiStepLabel-active': {\n          color: ({\n            options: {\n              activeLabelColor\n            }\n          }) => style.getColor(activeLabelColor)\n        }\n      }\n    },\n    stepButton: {\n      pointerEvents: isDev && 'none'\n    },\n    mobileRoot: {\n      backgroundColor: ({\n        options: {\n          backgroundColor\n        }\n      }) => [style.getColor(backgroundColor), '!important'],\n      color: ({\n        options: {\n          stepProgressColor\n        }\n      }) => [style.getColor(stepProgressColor), '!important']\n    },\n    stepButtonMobile: {\n      pointerEvents: isDev && 'none',\n      color: ({\n        options: {\n          activeColor\n        }\n      }) => [style.getColor(activeColor), '!important'],\n      '&:disabled': {\n        color: ({\n          options: {\n            inactiveColor\n          }\n        }) => [style.getColor(inactiveColor), '!important']\n      }\n    },\n    stepIcon: {\n      fill: ({\n        options: {\n          inactiveColor\n        }\n      }) => [style.getColor(inactiveColor), '!important']\n    },\n    stepIconActive: {\n      fill: ({\n        options: {\n          activeColor\n        }\n      }) => [style.getColor(activeColor), '!important']\n    },\n    empty: {\n      display: 'flex',\n      alignItems: 'center',\n      justifyContent: 'center',\n      height: '2.5rem',\n      fontSize: '0.75rem',\n      color: '#262A3A',\n      textTransform: 'uppercase',\n      borderWidth: '0.0625rem',\n      borderColor: '#AFB5C8',\n      borderStyle: 'dashed',\n      backgroundColor: '#F0F1F5'\n    }\n  };\n}","functions":["Refetch","NextStep","PreviousStep"],"triggers":["onFirstStep","onLastStep","onBetweenStep","onSuccess","onNoResults","onError","onLoad"],"interactions":{},"componentHash":"e342c0a2f532e1b492e454c0ed25f9d03d4e42c597d2271867f86a3b9cd46ae8"},{"name":"DynamicTabs","type":"CONTENT_COMPONENT","allowedTypes":["BODY_COMPONENT","CONTAINER_COMPONENT","CONTENT_COMPONENT"],"orientation":"HORIZONTAL","jsx":"(() => {\n  const {\n    Tabs,\n    Tab,\n    Typography,\n    Box\n  } = window.MaterialUI.Core;\n  const {\n    Icons\n  } = window.MaterialUI;\n  const {\n    env,\n    getProperty,\n    useFilter,\n    useAllQuery,\n    ModelProvider,\n    InteractionScope\n  } = B;\n  const {\n    model,\n    filter,\n    order,\n    orderBy,\n    variant,\n    centered,\n    scrollButtons,\n    alignment,\n    hideTabs,\n    labelProperty,\n    iconProperty,\n    disableRipple,\n    iconAlignment\n  } = options;\n  const orientation = alignment === 'top' || alignment === 'bottom' ? 'horizontal' : 'vertical';\n  const isDev = env === 'dev';\n  const [value, setValue] = useState(0);\n\n  const handleChange = (_, newValue) => {\n    setValue(newValue);\n  };\n\n  const getFlexDirection = () => {\n    switch (iconAlignment) {\n      case 'top':\n        return 'column';\n\n      case 'right':\n        return 'row-reverse';\n\n      case 'bottom':\n        return 'column-reverse';\n\n      default:\n        return 'row';\n    }\n  };\n\n  const orderByPath = Array.isArray(orderBy.id) ? orderBy.id : null;\n  const sort = !isDev && orderByPath ? orderByPath.reduceRight((acc, property, index) => {\n    const prop = getProperty(property);\n    return index === orderByPath.length - 1 ? {\n      [prop.name]: order.toUpperCase()\n    } : {\n      [prop.name]: acc\n    };\n  }, {}) : {};\n  const where = useFilter(filter);\n  const {\n    loading,\n    error,\n    data,\n    refetch\n  } = model && useAllQuery(model, {\n    rawFilter: where,\n    skip: 0,\n    take: 200,\n    variables: { ...(orderByPath ? {\n        sort: {\n          relation: sort\n        }\n      } : {})\n    },\n\n    onCompleted(res) {\n      const hasResult = res && res.results && res.results.length > 0;\n\n      if (hasResult) {\n        B.triggerEvent('onSuccess', res.results);\n      } else {\n        B.triggerEvent('onNoResults');\n      }\n    },\n\n    onError(resp) {\n      if (!displayError) {\n        B.triggerEvent('onError', resp);\n      }\n    }\n\n  });\n  B.defineFunction('Refetch', () => refetch());\n  const mounted = useRef(false);\n  useEffect(() => {\n    mounted.current = true;\n    return () => {\n      mounted.current = false;\n    };\n  }, []);\n  useEffect(() => {\n    if (mounted.current && loading) {\n      B.triggerEvent('onLoad', loading);\n    }\n  }, [loading]);\n\n  const Looper = results => {\n    const tabs = results.map((item, index) => <ModelProvider key={item.id} value={item} id={model}>\n\t\t\t\t\t<InteractionScope model={model}>\n\t\t\t\t\t\t{context => {\n          return <Typography component='div' role='tabpanel' hidden={value != index} aria-labelledby='tabs' classes={{\n            root: classes.tabRoot\n          }}>\n\t\t\t\t\t\t\t\t\t{children.length === 0 ? <></> : children}\n\t\t\t\t\t\t\t\t</Typography>;\n        }}\n\t\t\t\t\t</InteractionScope>\n\t\t\t\t</ModelProvider>);\n    return tabs;\n  };\n\n  const TabsHeader = results => <Tabs aria-label='tabs' onChange={handleChange} value={value} variant={variant} centered={centered} orientation={orientation} scrollButtons={scrollButtons} classes={{\n    root: classes.root,\n    indicator: classes.indicator\n  }}>\n\t\t\t\t{results.map(item => {\n      const label = labelProperty === '' || labelProperty.id === '' ? undefined : getProperty(labelProperty).name;\n      const icon = iconProperty === '' || iconProperty.id === '' ? undefined : getProperty(iconProperty).name;\n\n      const getFlexDirection = () => {\n        switch (iconAlignment) {\n          case 'top':\n            return 'column';\n\n          case 'right':\n            return 'row-reverse';\n\n          case 'bottom':\n            return 'column-reverse';\n\n          default:\n            return 'row';\n        }\n      };\n\n      return <Tab label={<div className={classes.labelWrapper} style={{\n        flexDirection: getFlexDirection()\n      }}>\n\t\t\t\t\t\t\t\t\t<div className={classes.iconWrapper}>\n\t\t\t\t\t\t\t\t\t\t{icon && icon !== undefined ? React.createElement(Icons[icon]) : undefined}\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t<div>{item[label]}</div>\n\t\t\t\t\t\t\t\t</div>} disableRipple={disableRipple} />;\n    })}\n\t\t\t</Tabs>;\n\n  const TabGroup = () => {\n    if (loading) return <div className={classes.skeleton} />;\n\n    if (error) {\n      return <span>{error.message}</span>;\n    }\n\n    const {\n      results\n    } = data || {};\n    return <div className={classes.tabs}>\n\t\t\t\t\t{!hideTabs && TabsHeader(results)}\n\t\t\t\t\t{Looper(results)}\n\t\t\t\t</div>;\n  };\n\n  const EmptyBox = () => {\n    if (!isDev) return null;\n    return <Box className={classes.empty} p={3}>\n\t\t\t\t\tTab\n\t\t\t\t</Box>;\n  };\n\n  const BuilderLayout = () => {\n    return <div className={classes.tabs}>\n\t\t\t\t\t<Tabs aria-label='tabs' onChange={handleChange} value={value} variant={variant} centered={centered} orientation={orientation} scrollButtons={scrollButtons} classes={{\n        root: classes.root,\n        indicator: classes.indicator\n      }}>\n\t\t\t\t\t\t<Tab label={<div className={classes.labelWrapper} style={{\n          flexDirection: getFlexDirection()\n        }}>\n\t\t\t\t\t\t\t\t\t<div className={classes.iconWrapper}>\n\t\t\t\t\t\t\t\t\t\t{iconProperty === '' || iconProperty.id === '' ? undefined : React.createElement(Icons['Star'])}\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t<div>Dynamic tab</div>\n\t\t\t\t\t\t\t\t</div>} disableRipple={disableRipple} />\n\t\t\t\t\t</Tabs>\n\n\t\t\t\t\t<Typography component='div' role='tabpanel' aria-labelledby='tabs' classes={{\n        root: classes.tabRoot\n      }}>\n\t\t\t\t\t\t{children.length === 0 ? <EmptyBox /> : children}\n\t\t\t\t\t</Typography>\n\t\t\t\t</div>;\n  };\n\n  return isDev ? <div className={[classes.wrapper, children.length === 0 && classes.empty].join(' ')}>\n\t\t\t\t{BuilderLayout()}\n\t\t\t</div> : TabGroup();\n})()","styles":"B => t => {\n  const {\n    env,\n    Styling\n  } = B;\n  const style = new Styling(t);\n  const isDev = env === 'dev';\n  return {\n    wrapper: {\n      height: ({\n        options: {\n          height\n        }\n      }) => height,\n      width: ({\n        options: {\n          width\n        }\n      }) => width,\n      '& .MuiTabs-flexContainer > button': {\n        pointerEvents: 'none'\n      }\n    },\n    tabs: {\n      display: 'flex',\n      height: ({\n        options: {\n          height\n        }\n      }) => isDev ? '100%' : height,\n      width: ({\n        options: {\n          width\n        }\n      }) => isDev ? '100%' : width,\n      flexDirection: ({\n        options: {\n          alignment\n        }\n      }) => {\n        switch (alignment) {\n          case 'top':\n            return 'column';\n\n          case 'right':\n            return 'row-reverse';\n\n          case 'bottom':\n            return 'column-reverse';\n\n          default:\n            return 'row';\n        }\n      }\n    },\n    root: {\n      backgroundColor: ({\n        options: {\n          appBarColor\n        }\n      }) => [style.getColor(appBarColor), '!important'],\n      color: ({\n        options: {\n          textColor\n        }\n      }) => [style.getColor(textColor), '!important'],\n      minWidth: '10rem'\n    },\n    tabRoot: {\n      height: ({\n        options: {\n          height\n        }\n      }) => isDev ? '100%' : height,\n      width: ({\n        options: {\n          width\n        }\n      }) => isDev ? '100%' : width\n    },\n    indicator: {\n      left: ({\n        options: {\n          alignment\n        }\n      }) => alignment === 'right' && 0,\n      top: ({\n        options: {\n          alignment\n        }\n      }) => alignment === 'bottom' && 0,\n      backgroundColor: ({\n        options: {\n          indicatorColor\n        }\n      }) => [style.getColor(indicatorColor), '!important']\n    },\n    labelWrapper: {\n      display: 'flex',\n      alignItems: 'center'\n    },\n    iconWrapper: {\n      marginLeft: 5,\n      marginRight: 5,\n      display: 'flex',\n      alignItems: 'center'\n    },\n    empty: {\n      display: 'flex',\n      alignItems: 'center',\n      justifyContent: 'center',\n      minHeight: '4rem',\n      fontSize: '0.75rem',\n      color: '#262A3A',\n      textTransform: 'uppercase',\n      boxSizing: 'border-box',\n      borderWidth: '0.0625rem',\n      borderColor: '#AFB5C8',\n      borderStyle: 'dashed',\n      backgroundColor: '#F0F1F5'\n    }\n  };\n}","functions":["Refetch"],"triggers":["onSuccess","onNoResults","onError","onLoad"],"interactions":{},"componentHash":"adb8cbcb260c8beed40995b027392b05c8c3bcc140c4c870eba0b184e61bf79b"}]
